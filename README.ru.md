# Расширяемое перечисление

Проект предоставляет класс ```SuperEnum```.

```SuperEnum``` — это шаблонный класс, который позволяет создавать расширяемые перечисления.

Перечисление создается с помощью наследования класса ```SuperEnum```. Тип расширяемого перечисления — это класс, а элементы перечисления — объекты этого класса.

Классическое перечисление создается следующим образом:

```cpp
enum MyEnum {Element1, Element2, Element3};
```

Язык C++ не позволяет добавить элементы в перечисление вне этой конструкции. Но в некоторых задачах было бы полезно иметь перечисление с обязательным набором элементов и возможностью добавить в набор пользовательские элементы.

Существуют разные [способы](https://stackoverflow.com/questions/644629/base-enum-class-inheritance) сделать расширяемое или наследуемое перечисление.


## Особенности ```SuperEnum```

* Автоматическая нумерация элементов.
* Ручная нумерация элементов.
* Отрицательные номера элементов.
* Ограничение на создание элементов с одинаковыми номерами.

Правила нумерации, как в обычном перечислении. Первому элементу без явного номера присваивается номер 0, следующему — 1, и так далее. Если присвоить элементу номер N, то следующий созданный элемент будет иметь номер N+1.

## Применение

Для использования ```SuperEnum``` нужен только один файл super_enum.h. Следует подключить его в своей программе:

```cpp
#include "super_enum.h"
```

В заголовочном файле my_enum.h создается класс ```MyEnum```, который наследует класс ```SuperEnum``` следующим образом:

```cpp
class MyEnum: public SuperEnum<MyEnum>
{
public:
    MyEnum() {}
    explicit MyEnum(const int &value): SuperEnum(value) {}

    static const MyEnum element1;
    static const MyEnum element2;
    static const MyEnum element3;
};
```

В качестве шаблоного параметра класса ```SuperEnum``` используется создаваемый класс ```MyEnum```: ```SuperEnum<MyEnum>```.

Создается два конструктора: первый для автоматической нумерации элементов и второй для ручной.

Объявляется несколько элементов перечисления. Элемент — это статический константный объект этого же класса.

В файле my_enum.cpp определяются элементы, и им присваются номера следующим образом.

```cpp
const MyEnum MyEnum::element1(1);
const MyEnum MyEnum::element2;
const MyEnum MyEnum::element3;
```

Порядок определения элементов влияет на их нумерацию. Нумерация растет с определением следующего элемента.

Обращение к элементам перечисления:

```cpp
std::cout << MyEnum::element3;
// Вывод: 3
```

Создавать новые элементы можно как обычные переменные:

``` cpp
const MyEnum element4;
const MyEnum element5;
```

или как члены производного класса:

```cpp
class MyEnum2: public MyEnum
{
public:
    MyEnum2() {}
    explicit MyEnum2(const int &value): MyEnum(value) {}

    static const MyEnum2 element4;
    static const MyEnum2 element5;
};

const MyEnum2 MyEnum2::element4;
const MyEnum2 MyEnum2::element5;
```

При этом обращаться к элементам базового класса, через производный:

```cpp
std::cout << MyEnum2::element3;
// Вывод: 3
```

Передавать элементы следует как ссылки или указатели.

```cpp
// Пример 1
void fun(const MyEnum2 *element);
void fun(const MyEnum2 &element);

// Пример 2
const MyEnum *e1 = &MyEnum2::element1;
const MyEnum &e2 = MyEnum2::element2;
```
